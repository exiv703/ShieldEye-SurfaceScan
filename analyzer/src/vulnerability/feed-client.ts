import axios, { AxiosInstance } from 'axios';
import { Vulnerability, VulnerabilityCache, CacheUtils, RiskLevel } from '@shieldeye/shared';
import { logger } from '../logger';

export class VulnerabilityFeedClient {
  private osvClient: AxiosInstance;
  private nvdClient: AxiosInstance;
  private cache: Map<string, VulnerabilityCache> = new Map();

  constructor(config: {
    osv: { baseUrl: string; timeout: number };
    nvd: { baseUrl: string; apiKey?: string; timeout: number };
  }) {
    this.osvClient = axios.create({
      baseURL: config.osv.baseUrl,
      timeout: config.osv.timeout,
      headers: {
        'Content-Type': 'application/json'
      }
    });

    this.nvdClient = axios.create({
      baseURL: config.nvd.baseUrl,
      timeout: config.nvd.timeout,
      headers: {
        'Content-Type': 'application/json',
        ...(config.nvd.apiKey && { 'apiKey': config.nvd.apiKey })
      }
    });
  }

  async getVulnerabilities(packageName: string, version?: string): Promise<Vulnerability[]> {
    const cacheKey = CacheUtils.generateCacheKey(packageName, version);
    
    // Check cache first
    const cached = this.cache.get(cacheKey);
    if (cached && !CacheUtils.isExpired(cached.lastUpdated, cached.ttl)) {
      logger.debug('Using cached vulnerabilities', { packageName, version });
      return cached.vulnerabilities;
    }

    const vulnerabilities: Vulnerability[] = [];

    try {
      // Fetch from OSV
      const osvVulns = await this.fetchFromOSV(packageName, version);
      vulnerabilities.push(...osvVulns);

      // Fetch from NVD (if API key available)
      const nvdVulns = await this.fetchFromNVD(packageName, version);
      vulnerabilities.push(...nvdVulns);

      // Deduplicate vulnerabilities
      const deduped = this.deduplicateVulnerabilities(vulnerabilities);

      // Cache the results
      this.cache.set(cacheKey, {
        packageName,
        version: version || '',
        vulnerabilities: deduped,
        lastUpdated: new Date(),
        ttl: 3600 // 1 hour
      });

      logger.info('Fetched vulnerabilities', { 
        packageName, 
        version, 
        count: deduped.length 
      });

      return deduped;

    } catch (error) {
      logger.error('Error fetching vulnerabilities', {
        packageName,
        version,
        error: error instanceof Error ? error.message : error
      });
      return [];
    }
  }

  private async fetchFromOSV(packageName: string, version?: string): Promise<Vulnerability[]> {
    try {
      const query = {
        package: {
          name: packageName,
          ecosystem: 'npm'
        },
        ...(version && { version })
      };

      const response = await this.osvClient.post('/v1/query', query);
      const osvData = response.data;

      if (!osvData.vulns) {
        return [];
      }

      return osvData.vulns.map((vuln: any) => this.parseOSVVulnerability(vuln));

    } catch (error) {
      logger.warn('Failed to fetch from OSV', {
        packageName,
        version,
        error: error instanceof Error ? error.message : error
      });
      return [];
    }
  }

  private async fetchFromNVD(packageName: string, version?: string): Promise<Vulnerability[]> {
    try {
      // NVD API requires different approach - search by CPE or keyword
      const params = {
        keywordSearch: packageName,
        resultsPerPage: 50
      };

      const response = await this.nvdClient.get('/cves/2.0', { params });
      const nvdData = response.data;

      if (!nvdData.vulnerabilities) {
        return [];
      }

      return nvdData.vulnerabilities
        .map((item: any) => this.parseNVDVulnerability(item.cve))
        .filter((vuln: Vulnerability | null) => vuln !== null);

    } catch (error) {
      logger.warn('Failed to fetch from NVD', {
        packageName,
        version,
        error: error instanceof Error ? error.message : error
      });
      return [];
    }
  }

  private parseOSVVulnerability(osvVuln: any): Vulnerability {
    const severity = this.extractSeverity(osvVuln);
    const cvssScore = this.extractCVSSScore(osvVuln);

    return {
      id: osvVuln.id,
      osvId: osvVuln.id,
      cveId: osvVuln.aliases?.find((alias: string) => alias.startsWith('CVE-')),
      title: osvVuln.summary || 'No title available',
      description: osvVuln.details || 'No description available',
      severity,
      cvssScore,
      affectedVersions: this.extractAffectedVersions(osvVuln.affected),
      fixedVersion: this.extractFixedVersion(osvVuln.affected),
      publishedAt: new Date(osvVuln.published || Date.now()),
      references: osvVuln.references?.map((ref: any) => ref.url) || []
    };
  }

  private parseNVDVulnerability(nvdCve: any): Vulnerability | null {
    if (!nvdCve) return null;

    const severity = this.extractNVDSeverity(nvdCve);
    const cvssScore = this.extractNVDCVSSScore(nvdCve);

    return {
      id: nvdCve.id,
      cveId: nvdCve.id,
      title: nvdCve.descriptions?.find((desc: any) => desc.lang === 'en')?.value || 'No title available',
      description: nvdCve.descriptions?.find((desc: any) => desc.lang === 'en')?.value || 'No description available',
      severity,
      cvssScore,
      affectedVersions: [], // NVD doesn't provide version ranges in the same format
      publishedAt: new Date(nvdCve.published || Date.now()),
      references: nvdCve.references?.map((ref: any) => ref.url) || []
    };
  }

  private extractSeverity(osvVuln: any): RiskLevel {
    if (osvVuln.severity) {
      for (const sev of osvVuln.severity) {
        if (sev.type === 'CVSS_V3') {
          const score = parseFloat(sev.score);
          if (score >= 9.0) return RiskLevel.CRITICAL;
          if (score >= 7.0) return RiskLevel.HIGH;
          if (score >= 4.0) return RiskLevel.MODERATE;
          return RiskLevel.LOW;
        }
      }
    }
    return RiskLevel.LOW;
  }

  private extractCVSSScore(osvVuln: any): number | undefined {
    if (osvVuln.severity) {
      for (const sev of osvVuln.severity) {
        if (sev.type === 'CVSS_V3' && sev.score) {
          return parseFloat(sev.score);
        }
      }
    }
    return undefined;
  }

  private extractNVDSeverity(nvdCve: any): RiskLevel {
    const metrics = nvdCve.metrics;
    if (metrics?.cvssMetricV31?.[0]?.baseSeverity) {
      return this.mapSeverity(metrics.cvssMetricV31[0].baseSeverity);
    }
    if (metrics?.cvssMetricV30?.[0]?.baseSeverity) {
      return this.mapSeverity(metrics.cvssMetricV30[0].baseSeverity);
    }
    return RiskLevel.LOW;
  }

  private extractNVDCVSSScore(nvdCve: any): number | undefined {
    const metrics = nvdCve.metrics;
    if (metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore) {
      return metrics.cvssMetricV31[0].cvssData.baseScore;
    }
    if (metrics?.cvssMetricV30?.[0]?.cvssData?.baseScore) {
      return metrics.cvssMetricV30[0].cvssData.baseScore;
    }
    return undefined;
  }

  private extractAffectedVersions(affected: any[]): string[] {
    if (!affected) return [];

    const versions: string[] = [];
    for (const item of affected) {
      if (item.ranges) {
        for (const range of item.ranges) {
          if (range.events) {
            for (const event of range.events) {
              if (event.introduced) versions.push(`>=${event.introduced}`);
              if (event.fixed) versions.push(`<${event.fixed}`);
            }
          }
        }
      }
      if (item.versions) {
        versions.push(...item.versions);
      }
    }
    return versions;
  }

  private extractFixedVersion(affected: any[]): string | undefined {
    if (!affected) return undefined;

    for (const item of affected) {
      if (item.ranges) {
        for (const range of item.ranges) {
          if (range.events) {
            for (const event of range.events) {
              if (event.fixed) {
                return event.fixed;
              }
            }
          }
        }
      }
    }
    return undefined;
  }

  private deduplicateVulnerabilities(vulnerabilities: Vulnerability[]): Vulnerability[] {
    const seen = new Set<string>();
    const deduped: Vulnerability[] = [];

    for (const vuln of vulnerabilities) {
      const key = vuln.cveId || vuln.osvId || vuln.id;
      if (!seen.has(key)) {
        seen.add(key);
        deduped.push(vuln);
      }
    }

    return deduped;
  }

  clearCache(): void {
    this.cache.clear();
    logger.info('Vulnerability cache cleared');
  }

  getCacheStats(): { size: number; keys: string[] } {
    return {
      size: this.cache.size,
      keys: Array.from(this.cache.keys())
    };
  }

  private mapSeverity(sev: string): RiskLevel {
    switch ((sev || '').toUpperCase()) {
      case 'CRITICAL':
        return RiskLevel.CRITICAL;
      case 'HIGH':
        return RiskLevel.HIGH;
      case 'MEDIUM':
        return RiskLevel.MODERATE;
      case 'LOW':
      default:
        return RiskLevel.LOW;
    }
  }
}
