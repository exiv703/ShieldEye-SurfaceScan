// @ts-nocheck
import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';

let queryMock: any;
let endMock: any;

jest.mock('pg', () => {
  return {
    Pool: jest.fn(() => ({
      query: (...args: any[]) => queryMock(...args),
      on: jest.fn(),
      end: (...args: any[]) => endMock(...args),
      totalCount: 0,
      idleCount: 0,
      waitingCount: 0,
    })),
  };
});

describe('Database vulnerability_cache helpers', () => {
  let Database: any;
  let db: any;

  beforeEach(async () => {
    jest.resetModules();
    queryMock = jest.fn();
    endMock = jest.fn().mockResolvedValue(undefined);

    const mod = await import('../database');
    Database = mod.Database;

    db = new Database();
  });

  afterEach(async () => {
    if (db) {
      await db.close();
    }
  });

  it('getVulnerabilityCacheEntry returns null when no rows', async () => {
    queryMock.mockResolvedValueOnce({ rows: [] });

    const res = await db.getVulnerabilityCacheEntry('lodash', '4.17.21');
    expect(res).toBeNull();

    expect(queryMock).toHaveBeenCalledTimes(1);
    const [sql, params] = queryMock.mock.calls[0];
    expect(String(sql)).toContain('FROM vulnerability_cache');
    expect(params).toEqual(['lodash', '4.17.21']);
  });

  it('getVulnerabilityCacheEntry returns cached payload when row exists', async () => {
    const last = new Date(Date.now() - 60 * 1000); // not expired
    queryMock.mockResolvedValueOnce({
      rows: [
        {
          vulnerabilities: [{ id: 'OSV-1', cvssScore: 9.8 }],
          last_updated: last,
          ttl: 3600,
        },
      ],
    });

    const res = await db.getVulnerabilityCacheEntry('lodash', null);

    expect(res).toEqual({
      vulnerabilities: [{ id: 'OSV-1', cvssScore: 9.8 }],
      lastUpdated: last,
      ttl: 3600,
    });

    const [, params] = queryMock.mock.calls[0];
    expect(params).toEqual(['lodash', null]);
  });

  it('getVulnerabilityCacheEntry returns null when TTL is expired', async () => {
    const last = new Date(Date.now() - 10 * 1000);
    queryMock.mockResolvedValueOnce({
      rows: [
        {
          vulnerabilities: [{ id: 'OSV-expired' }],
          last_updated: last,
          ttl: 1, // expired after 1s
        },
      ],
    });

    const res = await db.getVulnerabilityCacheEntry('pkg', '1.0.0');
    expect(res).toBeNull();
  });

  it('upsertVulnerabilityCacheEntry performs an upsert with JSON vulnerabilities', async () => {
    queryMock.mockResolvedValueOnce({ rowCount: 1 });

    const vulns = [{ id: 'OSV-2', title: 'Test', cvssScore: 7.5 }];
    await db.upsertVulnerabilityCacheEntry('react', '18.2.0', vulns, 86400);

    expect(queryMock).toHaveBeenCalledTimes(1);
    const [sql, params] = queryMock.mock.calls[0];

    expect(String(sql)).toContain('INSERT INTO vulnerability_cache');
    expect(String(sql)).toContain('ON CONFLICT');

    // params: [uuid, packageName, version, JSON.stringify(vulns), ttl]
    expect(params[1]).toBe('react');
    expect(params[2]).toBe('18.2.0');
    expect(params[3]).toBe(JSON.stringify(vulns));
    expect(params[4]).toBe(86400);
  });
});
