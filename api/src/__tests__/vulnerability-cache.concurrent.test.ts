// @ts-nocheck
import { describe, it, expect, beforeAll, afterAll, jest } from '@jest/globals';
import { Pool } from 'pg';
import { v4 as uuidv4 } from 'uuid';

// This is an integration-ish concurrency test. It will use a real Postgres if available.
// We must use real timers here because the global Jest setup uses fake timers.

describe('vulnerability_cache concurrency (no deadlock)', () => {
  let pool: Pool;

  beforeAll(async () => {
    jest.useRealTimers();

    const url =
      process.env.INTEGRATION_DATABASE_URL ||
      'postgresql://shieldeye:shieldeye_dev@localhost:55432/shieldeye';

    pool = new Pool({ connectionString: url });

    // Quick sanity check
    await pool.query('SELECT 1');
  }, 20000);

  afterAll(async () => {
    if (pool) {
      await pool.end();
    }
  });

  it('concurrent upserts on same (package_name, version) do not deadlock', async () => {
    const pkg = `jest-concurrent-${Date.now()}`;
    const version = '1.2.3';

    const sql = `
      INSERT INTO vulnerability_cache (id, package_name, version, vulnerabilities, last_updated, ttl)
      VALUES ($1, $2, $3, $4, NOW(), $5)
      ON CONFLICT (package_name, version)
      DO UPDATE SET
        vulnerabilities = EXCLUDED.vulnerabilities,
        last_updated   = NOW(),
        ttl            = EXCLUDED.ttl
    `;

    const ops = Array.from({ length: 20 }).map((_, i) => {
      const vulns = JSON.stringify([{ id: `OSV-${i}`, cvssScore: 5.0 + i }]);
      return pool.query(sql, [uuidv4(), pkg, version, vulns, 60]);
    });

    await expect(Promise.all(ops)).resolves.toBeTruthy();

    const res = await pool.query(
      'SELECT vulnerabilities, ttl FROM vulnerability_cache WHERE package_name = $1 AND version = $2',
      [pkg, version],
    );
    expect(res.rows.length).toBe(1);

    // cleanup
    await pool.query('DELETE FROM vulnerability_cache WHERE package_name = $1 AND version = $2', [pkg, version]);
  }, 20000);
});
